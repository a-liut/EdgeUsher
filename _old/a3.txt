:- use_module(library(lists)).

%Prima versione che determina possibili placement controllando 
%sia vincoli su HW e Things dei nodi che vincoli di latenza e
%banda sul flow tra i servizi.
%KNOWN LIMITATIONS: 
%1-per ora considera solo link diretti (ovvero path lunghi 1)
%2-controlla vincoli di flusso in modo non cumulativo

query(findPlacement(P,T,T2)).

findPlacement(Placement,Temp,Temp2) :-
    findall(s(X,Y,W),service(X,Y,W),Services),
    place(Services,[],Placement),
    checkFlows(Placement,Temp,Temp2).

place([],_,[]).
place([s(C,HReqs,TReqs)|Cs],HWalloc,[on(C,X)|P]) :-
	place1(s(C,HReqs,TReqs),HWalloc,X),
	place(Cs,[(X,HReqs)|HWalloc],P),
	findall(f(X, Y, LReq, BReq), (member(on(D,Y),P), flow(C, D, LReq, BReq)), Flows),
	%placeFlows(Flows, BAlloc),
	writenl(Flows).

place1(s(C,HReqs,TReqs),HWAlloc,X) :-
	node(X,_,HCaps,TCaps),
	checkTReqs(TReqs,TCaps),
	checkHReqs(HReqs,X,HCaps,HWAlloc).

%placeFlows():-
	

path(X, Y, P, [Y|P], L, B, LReq, BReq, [l(X,Y,BReq)] ) :- 
	writenl([l(X,Y,BReq)]),
	link(X, Y, L, B),
	LReq >= L,
	BReq =< B.
path(X, Y, Visited, Path, L, B, LReq, BReq, [l(X,Z,BReq)|Flow]) :-
	link(X, Z, Lxz, Bxz),           
	Z \== Y,
	\+ member(Z,Visited),
	path(Z,Y,[Z|Visited],Path, Lzy, Bzy, LReq, BReq, Flow),
	writenl([l(X,Z,BReq)|Flow]),
	L is Lxz + Lzy,
	B is min(Bxz, Bzy),
	LReq >= L,
	BReq =< B. 

checkTReqs([],_).
checkTReqs([R|Rs],TCaps) :-
	member(R,TCaps),
	checkTReqs(Rs,TCaps).

checkHReqs(HReqs,X,HCaps,Alloc) :-
	sumAlloc(X,Alloc,TotAllocX),
	UpdatedHCaps is HCaps-TotAllocX,
	HReqs < UpdatedHCaps.
	
sumAlloc(X,[],0).
sumAlloc(X,[(X,K)|Ls],NewS) :-
	sumAlloc(X,Ls,S),
	NewS is S+K.
sumAlloc(X,[(Y,K)|Ls],S) :-
   	X \== Y,
	sumAlloc(X,Ls,S).

checkFlows(Placement,NodeFlows,Paths) :-
	findall(f(X,Y,L,B),flow(X,Y,L,B),ServiceFlows),
	findNodeFlows(ServiceFlows,Placement,NodeFlows),
	findPaths(NodeFlows,[],Paths).

findNodeFlows([],_,[]).
findNodeFlows([f(X,Y,L,B)|SFs],P,[nf(Nx,Ny,L,B)|NFs]):-
	member(on(X,Nx),P),
	member(on(Y,Ny),P),
	findNodeFlows(SFs,P,NFs).

findPaths([],Ps,Ps).
findPaths([nf(Nx,Ny,L,B)|NFs],Ps,NewPs) :-
    	member(link(Nx,Ny,Ll,Bl),Ps), %deve anche prendere "min"
    	findPaths(NFs,Ps,NewPS).
findPaths([nf(Nx,Ny,L,B)|NFs],Ps,NewPs) :-
    	\+ member(link(Nx,Ny,Ll,Bl),Ps),
    	link(Nx,Ny,Ll,Bl),        %***solo link diretti per ora
    	Ll < L,
	Bl > B,
	findPaths(NFs,[link(Nx,Ny,Ll,Bl)|Ps],NewPs).

% services
service(s1, 3, [thing1]).
service(s2, 4, [thing2]).
service(s3, 7, []).
flow(s1, s2, 70, 4).
flow(s2, s3, 59, 2).

% infrastructure/nodes
node(fog1, opA, 7, [thing1]).
node(fog2, opB, 12, [thing2]).
node(cloud1, opC, 100000, []).

link(fog1, fog2, 11, 12).
    %link(fog1, fog2, 10, 13).
link(fog2, cloud1, 58, 8).
    %link(fog2, cloud1, 57, 9).
link(fog1, cloud1, 90, 8).

   


%%%%%%%%%
% Utils
%%%%%%%%%

forall(G, C) :- not((G, not(C))).

del(X, [X|L], L).
del(X, [Y|L], [Y|L1]) :-
    del(X, L, L1).